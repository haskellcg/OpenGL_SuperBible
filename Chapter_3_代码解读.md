## 客户机-服务器
  OpenGL的客户端是存储在CPU存储器中的，并且**在应用程序中执行**，或者在主系统内存中的驱动程序中执行。驱动程序将渲染命令与数据结合起来。
  
  在一台典型的桌面计算机上，服务器会跨越一些系统总线，实际上，它就是**图形加速卡的硬件和内存**。
  
  客户机和服务器在功能上也是**异步**的，也就是说它们有各自独立的软件块和硬件块，或者软硬件都有。为获得最佳性能，我们希望两方面都尽可能不停工作。客户机不断地将**数据块**和**命令块**组合在一起并送入**缓冲区**，然后这些缓冲区会发送给服务器执行。服务器将执行这些缓冲区内的内容，与此同时客户端又做好发送一下一个用于渲染的数据和信息的准备。
  
  如果服务器停止工作等待客户机，或者客户机停止工作等待服务器做好接收的准备，这种情况叫做**管线停滞**。管线停滞是注重性能程序员的噩梦，我们真的不希望CPU或者GPU无所事事等待工作。
  
## 着色器
  顶点着色器、片段着色器，使用GLSL编写，这些着色器必须从源码中编译链接在一起，最终准备就绪的着色器程序在随后第一阶段构成顶点着色器、第二阶段构成片段着色器。
  
  **顶点着色器**处理从客户端输入的数据，应用变换，或者进行其他类型的数学运算来计算光照效果、位移、颜色值。
  
  每个片段都通过**片段着色器**而进行了填充，片段着色器会输出我们将在屏幕上看到的最终颜色值。
  
  我们必须为这些着色器提供数据:
  
  * **属性**: 一个对每个顶点都要做改变的元素，属性总是以四维向量的形式进行内部存储。除了顶点的空间位置之外，还有一些其他可能要逐个修改的属性，包括**纹理坐标、颜色值和用于光照计算的表面法线**，不过，在顶点程序中，属性可以代表我们想要任何意义。属性会从**本地客户机内存中**复制存储在**图形硬件中**的一个缓冲区上，这些属性只供顶点着色器使用。
  
  * **Uniform值**: 我们通常设置哇Uniform变量就发出渲染一个图元批次的命令，Uniform变量实际上可以无限制次数使用。Uniform变量最常见的应用在顶点渲染中设置**变换矩阵**。顶点着色器和片段着色器都可以有Uniform变量。
  
  * **纹理**: 从顶点着色器到片段着色器都可以对纹理直进行采样和筛选，典型情况下，片段着色器对一个纹理进行采样，并在一个三角形的表面应用图形数据。但是，纹理数据的作用不仅仅是**图形表现**，很多**图形文件格式都是以无符号字节形式对颜色分量进行存储**。
  
  * **输出**:输出数据是作为一个阶段着色器的输出定义的，而在后续阶段的着色器则是作为输入定义的。输出类型数据可以简单的从一个阶段传递到下一个阶段，也可以以不同的方式插入。
  
## 创建坐标系
  这些投影，或者说坐标系类型，实际上只是一种**特定的4x4变换矩阵**，如果我们不采用这些矩阵，则会**默认获取一个坐标范围在-1.0到+1.0之间的正投影**。
  
  **Math3D**库是GLTools包含的函数的一部分，它为我们构建了不同种类的矩阵。在本章，我们使用**GLFrustum**类来作为投影矩阵的容器。
  
  * **正投影**: 我们通常在2d绘图中使用正投影，并在我们的几何图形中将z坐标设为0.0。**视景体**将包含所有的几何图形，如何指定了视景体之外的几何图形，那么它将被裁减掉。在正投影中，所有在这个空间范围内的所有东西都会被显示在屏幕上，而不存在**照相机**或**视点坐标系**的概念，我们通过调用下面函数完成上述工作：
  ```c++
  GLFrustum::SetOrthographic(GLfloat xMin, GLfloat xMax, 
                             GLfloat yMin, GLfloat yMax, 
                             GLfloat zMin, GLfloat zMax);
  ```

  * **透视投影**: 透视投影会进行**透视除法**对距离观察者很远的对象进行缩短和收缩。在投影到屏幕之后，视景体背面和视景体正面的宽度测量标准不同。这样逻辑尺寸相同的对象绘制在视景体的前面比绘制在视景体的背面显得更大。我们通过下面函数创建**平头截体(frustum)**:
  ```c++
  /**
   *@brief create frustum
   *@param float fFov, 垂直方向上的视场角度
   *@param float fAspect, 窗口的宽度和高度的纵横比
   *@param float fNear, 近裁截面的距离
   *@param float fFar, 远裁截面的距离
   */
  GLFrustum::SetPerspective(float fFov, float fAspect, float fNear, float fFar);
  ```

## 使用存储着色器
  在OpenGL核心框架中，并没有提供任何内建渲染管线。在提交一个几何图形进行渲染之前，必须制定一个着色器。
  
  这些着色器由GLTools的C++类GLShaderManager进行管理，它们能够满足进行通常渲染基本要求。在使用前必须进行初始化:
  ```c++
  shaderManager.InitializeStockShaders();
  ```
  
  * 属性: OpenGL支持多达16种可以为每个顶点设置不同的类型参数，这些参数编号从0到15，并且可以与**顶点着色器**中的任何指定变量相关联。**存储着色器**为每个变量都使用一致的内部变量命名规则和相同的属性槽
  标识符|描述
  -----|----
  GLT
  
  * Uniform值
    * 单位(Identity)着色器
    * 平面(Flat)着色器
    * 上色(Shaded)着色器
    * 默认光源着色器
    * 电光源着色器
    * 纹理替换矩阵
    * 纹理调整着色器
    * 纹理光源着色器
