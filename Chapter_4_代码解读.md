# 4.基础变换：初识向量/矩阵
## 4.1 本章时令人生畏的数学课吗

## 4.2 3D图形数学速成课
### 4.2.1 向量
  一个向量首先是空间中从原点指向这个点的方向。

  单位向量/标准化

  math3d库有两个数据类型：
  ```c++
  // M3DVector3f可以表示一个三维向量(X, Y, Z)
  typedef float M3DVector3f[3];

  // M3DVector4f可以表示一个四维向量(X, Y, Z, W)
  typedef float M3DVector4f[4];
  ```

  典型情况下，W坐标设为1.0，X、Y、Z值通过W来进行缩放。
  ```c++
  M3DVector3f vVertor;

  M3DVector4f vVertex = {0.0f, 0.0f, 1.0f, 1.0f};

  M3DVector3f vVerts = {-0.5f, 0.0f, 0.0f,
                        0.5f, 0.0f, 0.0f,
                        0.0f, 0.5f, 0.0f};
  ```

  点乘(dot product)：运算得到一个标量，它表示两个向量之间的夹角。在漫射光计算中，表面法向量和指向光源之间大量进行着这种运算。
  ```c++
  // 计算结果表示这两个单位向量之间的夹角的余弦值
  float m3dDotProduct3(const M3DVector3f u, const M3DVector3f v);

  // 计算结果更近一步，返回这个夹角的弧度值
  float m3dGetAngleBetweenVectors3(const M3DVector3f u, const M3DVector3f v);
  ```

  叉乘(cross product)：运算得到另一个向量，这个向量与原来两个向量定义的平面垂直：
  ```c++
  // 叉乘时向量的顺序时非常重要的
  void m3dCrossProduct3(M3DVector3f result, const M3DVector3f u, const M3DVector3f v);
  ```

### 4.2.2 矩阵
  矩阵(matrix)：大大简化了求解变量之间有复杂关系的方程或方程组的过程，例如坐标变换、旋转。
  ```c++
  // 3 x 3
  typedef float M3DMatrix33f[9];

  // 4 x 4
  typedef float M3DMatrix44f[16];
  ```

  OpenGL约定中拒绝了这个传统并使用了一个一维数组。这样做的原因是，OpenGL使用一种叫做Column-Major(以列为主的)矩阵排序的矩阵约定。

## 4.3 理解变换
  将3D数据被压扁成2D数据的处理过程叫做投影(projection)。

  投影、旋转对象、移动对象、伸展、收缩、扭曲

  变换|应用
  ----|----
  视图|指定观察者或照相机的位置
  模型|在场景中移动物体
  模型视图|描述视图和模型变换的二元性
  投影|改变视景体的大小或重新设置它的形状
  视口|这是一种伪变换，只是对窗口上的最终输出进行缩放

### 4.3.1 视觉坐标
  视觉坐标相对于观察者而言，无论可能进行何种变换，我们都可以将它们视为"绝对的"屏幕坐标。这样，视觉坐标就表示一个虚拟的固定坐标系，它通常作为参考坐标系使用。

  当我们利用OpenGL进行3D绘制时，就会使用笛卡尔坐标系。

### 4.3.2 视图变换
  视图变换是应用到场景中的第一种变换。他用来确定场景中的有利位置。在默认情况下，透视投影中的观察点位于原点(0, 0, 0)，并沿着z轴的负方向进行观察。

  当观察点位于原点时，就像透视投影中一样，绘制在z坐标为正的位置的对象则位于观察者背后。

  在正投影中，观察者被认为是在z轴正方向无穷远的位置，能够看到视景体中的任何东西。

  视图变换允许我们把观察点放在所希望的任何位置，并允许在任何方向观察场景。确定视图变换就像在场景中放置照相机并让它指向某个方向。

  从大局上考虑，视图变换移动了当前的工作坐标系，所有后续变换随后都会基于新调整的坐标系进行，所以在应用任何其他模型变换之前，必须首先应用视图变换。

### 4.3.3 模型变换
  模型变换用于操作模型以及其中特定的对象。这些变换将对象移动到需要的位置，然后再对它们进行旋转和缩放：
  * Translation: 平移
  * Rotation：旋转
  * Scaling: 缩放

  在变换过程中，模型自己的坐标系会随之变换，所以变换的顺序不同会造成不同的结果。

### 4.3.4 模型视图的二元性
  实际上，视图和模型变换按照它们内部效果和对场景的最终外观来说是一样的。

### 4.3.5 投影变换
  投影变换将在模型变换之后应用到顶点上。这种投影实际上定义了视景体并创建了剪裁平面。

  剪裁平面是3D空间中的平面方程式，OpenGL用它来确定几何图形对于观察者来说是否可见。更具体地来说，投影变换指定一个完成的场景时如何映射到屏幕上的最终图像。

  在正投影(或者说平行投影)中，所有多边形都是精确地按照指定的相对大小来在屏幕上绘制的。典型情况下，这种投影用于渲染二维图像，例如蓝图或者文本或屏幕菜单等二维图形。

  透视投影应用在渲染包括广阔的空间或者需要应用投射缩短的物体的场景时使用。在大多数情况下，透视投影都应用在3D图形中。

### 4.3.6 视口变换
  当所有这些讲述完成后，就得到一个场景的二维投影，它被映射到屏幕上某处的窗口上。这种到物理窗口坐标的映射时我们最后要做的变换，成为视口变换。

## 4.4 模型视图矩阵
